{
  "language": "Solidity",
  "sources": {
    "contracts/Airnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\nimport \"./interfaces/IAirnode.sol\";\nimport \"./EndpointStore.sol\";\nimport \"./TemplateStore.sol\";\n\n\n/// @title The contract used to make and fulfill requests\n/// @notice Clients use this contract to make requests that follow a\n/// request-fulfill cycle. In addition, it inherits from contracts that keep\n/// records of providers, requesters, endpoints, etc.\ncontract Airnode is EndpointStore, TemplateStore, IAirnode {\n    mapping(bytes32 => bytes32) private requestIdToProviderId;\n    mapping(bytes32 => bool) private requestWithIdHasFailed;\n    uint256 private noRequests = 0;\n\n\n    /// @notice Called by the requester to make a regular request. A regular\n    /// request refers to a template, yet requires the provider to ignore its\n    /// fulfill/error destinations and use the parameters supplied along with\n    /// the request.\n    /// @dev This is the recommended way of making a request in most cases. Use\n    /// makeShortRequest() if gas efficiency is critical.\n    /// @param templateId Template ID from TemplateStore\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param errorAddress Address that will be called to error\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param errorFunctionId Signature of the function that will be called\n    /// to error\n    /// @param parameters Dynamic request parameters (i.e., parameters that are\n    /// determined at runtime, unlike the static parameters stored in the\n    /// template)\n    /// @return requestId Request ID\n    function makeRequest(\n        bytes32 templateId,\n        address fulfillAddress,\n        address errorAddress,\n        bytes4 fulfillFunctionId,\n        bytes4 errorFunctionId,\n        bytes calldata parameters\n        )\n        external\n        override\n        returns (bytes32 requestId)\n    {\n        requestId = keccak256(abi.encodePacked(\n            noRequests++,\n            this,\n            msg.sender\n            ));\n        bytes32 providerId = templates[templateId].providerId;\n        requestIdToProviderId[requestId] = providerId;\n        emit RequestMade(\n            providerId,\n            requestId,\n            msg.sender,\n            templateId,\n            fulfillAddress,\n            errorAddress,\n            fulfillFunctionId,\n            errorFunctionId,\n            parameters\n        );\n    }\n\n    /// @notice Called by the requester to make a short request. A short\n    /// request refers to a template, which the provider will get all parameters\n    /// from (including fulfill/error destinations). This is the most gas\n    /// efficient method of making an individual request.\n    /// @dev Use this if gas efficiency is critical\n    /// @param templateId Template ID from TemplateStore\n    /// @param parameters Dynamic request parameters (i.e., parameters that are\n    /// determined at runtime, unlike the static parameters stored in the\n    /// template)\n    /// @return requestId Request ID\n    function makeShortRequest(\n        bytes32 templateId,\n        bytes calldata parameters\n        )\n        external\n        override\n        returns (bytes32 requestId)\n    {\n        requestId = keccak256(abi.encodePacked(\n            noRequests++,\n            this,\n            msg.sender\n            ));\n        bytes32 providerId = templates[templateId].providerId;\n        requestIdToProviderId[requestId] = providerId;\n        emit ShortRequestMade(\n            providerId,\n            requestId,\n            msg.sender,\n            templateId,\n            parameters\n        );\n    }\n\n    /// @notice Called by the requester to make a full request. It does not\n    /// refer to a template, meaning that it passes all the parameters in the\n    /// request. It does not require a template to be created beforehand,\n    /// which provides extra flexibility compared to makeRequest() and\n    /// makeShortRequest().\n    /// @dev This is the least gas efficient way of making a request. Do not\n    /// use it unless you have a good reason.\n    /// @param providerId Provider ID from ProviderStore\n    /// @param endpointId Endpoint ID from EndpointStore\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param errorAddress Address that will be called to error\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param errorFunctionId Signature of the function that will be called\n    /// to error\n    /// @param parameters All request parameters\n    /// @return requestId Request ID\n    function makeFullRequest(\n        bytes32 providerId,\n        bytes32 endpointId,\n        address fulfillAddress,\n        address errorAddress,\n        bytes4 fulfillFunctionId,\n        bytes4 errorFunctionId,\n        bytes calldata parameters\n        )\n        external\n        override\n        returns (bytes32 requestId)\n    {\n        requestId = keccak256(abi.encodePacked(\n            noRequests++,\n            this,\n            msg.sender\n            ));\n        requestIdToProviderId[requestId] = providerId;\n        emit FullRequestMade(\n            providerId,\n            requestId,\n            msg.sender,\n            endpointId,\n            fulfillAddress,\n            errorAddress,\n            fulfillFunctionId,\n            errorFunctionId,\n            parameters\n        );\n    }\n\n    /// @notice Called by the oracle node to fulfill individual requests\n    /// (including regular, short and full requests)\n    /// @param requestId Request ID\n    /// @param data Oracle response\n    /// @param fulfillAddress Address that will be called\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// @return callSuccess If the fulfillment call succeeded\n    /// @return callData Data returned by the fulfillment call (if there is\n    /// any)\n    function fulfill(\n        bytes32 requestId,\n        bytes32 data,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n        )\n        external\n        override\n        returns(\n            bool callSuccess,\n            bytes memory callData\n        )\n    {\n        bytes32 providerId = requestIdToProviderId[requestId];\n        require(\n            getProviderWalletStatus(providerId, msg.sender),\n            \"Not a valid wallet of the provider\"\n            );\n        delete requestIdToProviderId[requestId];\n        emit FulfillmentSuccessful(\n            providerId,\n            requestId,\n            data\n            );\n        (callSuccess, callData) = fulfillAddress.call(\n            abi.encodeWithSelector(fulfillFunctionId, requestId, data)\n            );\n    }\n\n    /// @notice Called by the oracle node to fulfill individual requests\n    /// (including regular, short and full requests) with a bytes type response\n    /// @dev The oracle uses this method to fulfill if the requester has\n    /// specifically asked for a bytes type response\n    /// @param requestId Request ID\n    /// @param data Oracle response of type bytes\n    /// @param fulfillAddress Address that will be called\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// @return callSuccess If the fulfillment call succeeded\n    /// @return callData Data returned by the fulfillment call (if there is\n    /// any)\n    function fulfillBytes(\n        bytes32 requestId,\n        bytes calldata data,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n        )\n        external\n        override\n        returns(\n            bool callSuccess,\n            bytes memory callData\n        )\n    {\n        bytes32 providerId = requestIdToProviderId[requestId];\n        require(\n            getProviderWalletStatus(providerId, msg.sender),\n            \"Not a valid wallet of the provider\"\n            );\n        delete requestIdToProviderId[requestId];\n        emit FulfillmentBytesSuccessful(\n            providerId,\n            requestId,\n            data\n            );\n        (callSuccess, callData) = fulfillAddress.call(\n            abi.encodeWithSelector(fulfillFunctionId, requestId, data)\n            );\n    }\n\n    /// @notice Called by the oracle node if a request could not be fulfilled\n    /// for any reason\n    /// @dev The oracle may specify the error using errorCode. The specification\n    /// format is outside the scope of this contract. Refer to the specific\n    /// oracle documentations for more information.\n    /// @param requestId Request ID\n    /// @param errorCode Error code\n    /// @param errorAddress Address that will be called\n    /// @param errorFunctionId Signature of the function that will be called\n    /// @return callSuccess If the fulfillment call succeeded\n    /// @return callData Data returned by the fulfillment call (if there is\n    /// any)\n    function error(\n        bytes32 requestId,\n        uint256 errorCode,\n        address errorAddress,\n        bytes4 errorFunctionId\n        )\n        external\n        override\n        returns(\n            bool callSuccess,\n            bytes memory callData\n        )\n    {\n        bytes32 providerId = requestIdToProviderId[requestId];\n        require(\n            getProviderWalletStatus(providerId, msg.sender),\n            \"Not a valid wallet of the provider\"\n            );\n        delete requestIdToProviderId[requestId];\n        emit FulfillmentErrored(\n            providerId,\n            requestId,\n            errorCode\n            );\n        (callSuccess, callData) = errorAddress.call(\n            abi.encodeWithSelector(errorFunctionId, requestId, errorCode)\n            );\n    }\n\n    /// @notice Called by the oracle node if a request could neither be fulfilled\n    /// nor errored\n    /// @dev The oracle should fall back to this if a request cannot be fulfilled\n    /// and error() is reverting\n    /// @param requestId Request ID\n    function fail(bytes32 requestId)\n        external\n        override\n    {\n        bytes32 providerId = requestIdToProviderId[requestId];\n        require(\n            getProviderWalletStatus(providerId, msg.sender),\n            \"Not a valid wallet of the provider\"\n            );\n        delete requestIdToProviderId[requestId];\n        // Failure is recorded so that it can be checked externally with\n        // checkIfRequestHasFailed()\n        requestWithIdHasFailed[requestId] = true;\n        emit FulfillmentFailed(\n            providerId,\n            requestId\n            );\n    }\n\n    /// @notice Used to check if a request has failed because it could neither\n    /// be fulfilled nor errored\n    /// @param requestId Request ID\n    /// @return status If the request has failed\n    function checkIfRequestHasFailed(bytes32 requestId)\n        external\n        view\n        returns(bool status)\n    {\n        status = requestWithIdHasFailed[requestId];\n    }\n}\n"
    },
    "contracts/interfaces/IAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\nimport \"./IEndpointStore.sol\";\nimport \"./ITemplateStore.sol\";\n\n\ninterface IAirnode is IEndpointStore, ITemplateStore {\n    event RequestMade(\n        bytes32 indexed providerId,\n        bytes32 requestId,\n        address requester,\n        bytes32 templateId,\n        address fulfillAddress,\n        address errorAddress,\n        bytes4 fulfillFunctionId,\n        bytes4 errorFunctionId,\n        bytes parameters\n        );\n\n    event ShortRequestMade(\n        bytes32 indexed providerId,\n        bytes32 requestId,\n        address requester,\n        bytes32 templateId,\n        bytes parameters\n        );\n\n    event FullRequestMade(\n        bytes32 indexed providerId,\n        bytes32 requestId,\n        address requester,\n        bytes32 endpointId,\n        address fulfillAddress,\n        address errorAddress,\n        bytes4 fulfillFunctionId,\n        bytes4 errorFunctionId,\n        bytes parameters\n        );\n\n    event FulfillmentSuccessful(\n        bytes32 indexed providerId,\n        bytes32 requestId,\n        bytes32 data\n        );\n\n    event FulfillmentBytesSuccessful(\n        bytes32 indexed providerId,\n        bytes32 requestId,\n        bytes data\n        );\n\n    event FulfillmentErrored(\n        bytes32 indexed providerId,\n        bytes32 requestId,\n        uint256 errorCode\n        );\n\n    event FulfillmentFailed(\n        bytes32 indexed providerId,\n        bytes32 requestId\n        );\n\n\n    function makeRequest(\n        bytes32 templateId,\n        address fulfillAddress,\n        address errorAddress,\n        bytes4 fulfillFunctionId,\n        bytes4 errorFunctionId,\n        bytes calldata parameters\n        )\n        external\n        returns (bytes32 requestId);\n\n    function makeShortRequest(\n        bytes32 templateId,\n        bytes calldata parameters\n        )\n        external\n        returns (bytes32 requestId);\n\n    function makeFullRequest(\n        bytes32 providerId,\n        bytes32 endpointId,\n        address fulfillAddress,\n        address errorAddress,\n        bytes4 fulfillFunctionId,\n        bytes4 errorFunctionId,\n        bytes calldata parameters\n        )\n        external\n        returns (bytes32 requestId);\n\n    function fulfill(\n        bytes32 requestId,\n        bytes32 data,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n        )\n        external\n        returns(\n            bool callSuccess,\n            bytes memory callData\n        );\n\n    function fulfillBytes(\n        bytes32 requestId,\n        bytes calldata data,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId\n        )\n        external\n        returns(\n            bool callSuccess,\n            bytes memory callData\n        );\n\n    function error(\n        bytes32 requestId,\n        uint256 errorCode,\n        address errorAddress,\n        bytes4 errorFunctionId\n        )\n        external\n        returns(\n            bool callSuccess,\n            bytes memory callData\n        );\n\n    function fail(bytes32 requestId)\n        external;\n}\n"
    },
    "contracts/interfaces/IEndpointStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\nimport \"./IProviderStore.sol\";\n\n\ninterface IEndpointStore is IProviderStore {\n    event EndpointCreated(\n        bytes32 indexed endpointId,\n        bytes32 providerId,\n        bytes32 apiId,\n        address[] authorizers\n        );\n\n    event EndpointUpdated(\n        bytes32 indexed endpointId,\n        bytes32 apiId,\n        address[] authorizers\n        );\n\n\n    function createEndpoint(\n        bytes32 providerId,\n        bytes32 apiId,\n        address[] calldata authorizers\n        )\n        external\n        returns(bytes32 endpointId);\n\n    function updateEndpoint(\n        bytes32 endpointId,\n        bytes32 apiId,\n        address[] calldata authorizers\n        )\n        external;\n\n    function getEndpoint(bytes32 endpointId)\n        external\n        view\n        returns(\n            bytes32 providerId,\n            bytes32 apiId,\n            address[] memory authorizers\n        );\n\n    function checkAuthorizationStatus(\n        bytes32 endpointId,\n        address clientAddress\n        )\n        external\n        view\n        returns(bool status);\n}\n"
    },
    "contracts/interfaces/IProviderStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\nimport \"./IRequesterStore.sol\";\n\n\ninterface IProviderStore is IRequesterStore {\n    event ProviderCreated(\n        bytes32 indexed providerId,\n        address admin,\n        uint256 walletDesignationDeposit,\n        uint256 minBalance\n        );\n\n    event ProviderUpdated(\n        bytes32 indexed providerId,\n        address admin,\n        uint256 walletDesignationDeposit,\n        uint256 minBalance\n        );\n\n    event ProviderKeysInitialized(\n        bytes32 indexed providerId,\n        string xpub,\n        address walletDesignator\n        );\n\n    event WalletDesignationRequested(\n        bytes32 indexed providerId,\n        bytes32 indexed requesterId,\n        bytes32 walletDesignationRequestId,\n        uint256 walletInd,\n        uint256 depositAmount\n        );\n\n    event WalletDesignationFulfilled(\n        bytes32 indexed providerId,\n        bytes32 indexed requesterId,\n        bytes32 walletDesignationRequestId,\n        address walletAddress,\n        uint256 walletInd\n        );\n\n    event WithdrawalRequested(\n        bytes32 indexed providerId,\n        bytes32 indexed requesterId,\n        bytes32 withdrawalRequestId,\n        address destination\n        );\n\n    event WithdrawalFulfilled(\n        bytes32 indexed providerId,\n        bytes32 indexed requesterId,\n        bytes32 withdrawalRequestId,\n        address destination,\n        uint256 amount\n        );\n\n\n    function createProvider(\n        address admin,\n        uint256 walletDesignationDeposit,\n        uint256 minBalance\n        )\n        external\n        returns (bytes32 providerId);\n\n    function updateProvider(\n        bytes32 providerId,\n        address admin,\n        uint256 walletDesignationDeposit,\n        uint256 minBalance\n        )\n        external;\n\n    function initializeProviderKeys(\n        bytes32 providerId,\n        string calldata xpub,\n        address walletDesignator\n        )\n        external;\n\n    function requestWalletDesignation(\n        bytes32 providerId,\n        bytes32 requesterId\n    )\n        external\n        payable\n        returns(uint256 walletInd);\n\n    function rebroadcastWalletDesignationRequest(bytes32 walletDesignationRequestId)\n        external;\n\n    function fulfillWalletDesignation(\n        bytes32 walletDesignationRequestId,\n        address walletAddress\n        )\n        external\n        payable;\n\n    function requestWithdrawal(\n        bytes32 providerId,\n        bytes32 requesterId,\n        address destination\n    )\n        external;\n\n    function fulfillWithdrawal(bytes32 withdrawalRequestId)\n        external\n        payable;\n\n    function getProvider(bytes32 providerId)\n        external\n        view\n        returns (\n            address admin,\n            string memory xpub,\n            address walletDesignator,\n            uint256 walletDesignationDeposit,\n            uint256 minBalance\n        );\n\n    function getProviderMinBalance(bytes32 providerId)\n        external\n        view\n        returns (uint256 minBalance);\n\n    function getProviderWalletStatus(\n        bytes32 providerId,\n        address walletAddress\n        )\n        external\n        view\n        returns (bool status);\n\n    function getProviderWalletIndWithAddress(\n        bytes32 providerId,\n        address walletAddress\n        )\n        external\n        view\n        returns (uint256 walletInd);\n\n    function getProviderWalletAddressWithInd(\n        bytes32 providerId,\n        uint256 walletInd\n        )\n        external\n        view\n        returns (address walletAddress);\n\n    function getProviderWalletIndWithRequesterId(\n        bytes32 providerId,\n        bytes32 requesterId\n        )\n        external\n        view\n        returns (uint256 walletInd);\n}\n"
    },
    "contracts/interfaces/IRequesterStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\n\ninterface IRequesterStore {\n    event RequesterCreated(\n        bytes32 indexed requesterId,\n        address admin\n        );\n\n    event RequesterUpdated(\n        bytes32 indexed requesterId,\n        address admin\n        );\n\n    event ClientEndorsed(\n        bytes32 indexed requesterId,\n        address indexed clientAddress\n        );\n\n    event ClientDisendorsed(\n        bytes32 indexed requesterId,\n        address indexed clientAddress\n        );\n\n    function createRequester(address admin)\n        external\n        returns (bytes32 requesterId);\n\n    function updateRequesterAdmin(\n        bytes32 requesterId,\n        address admin\n        )\n        external;\n\n    function updateEndorsementPermission(bytes32 requesterId)\n        external;\n\n    function endorseClient(\n        bytes32 requesterId,\n        address clientAddress\n        )\n        external;\n\n    function disendorseClient(\n        bytes32 requesterId,\n        address clientAddress\n        )\n        external;\n\n    function getRequesterAdmin(bytes32 requesterId)\n        external\n        view\n        returns (address admin);\n\n    function getClientRequesterId(address clientAddress)\n        external\n        view\n        returns (bytes32 requesterId);\n\n    function getClientPermittedEndorser(address clientAddress)\n        external\n        view\n        returns (bytes32 requesterId);\n}"
    },
    "contracts/interfaces/ITemplateStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\n\ninterface ITemplateStore {\n    event TemplateCreated(\n        bytes32 indexed templateId,\n        bytes32 providerId,\n        bytes32 endpointId,\n        address fulfillAddress,\n        address errorAddress,\n        bytes4 fulfillFunctionId,\n        bytes4 errorFunctionId,\n        bytes parameters\n        );\n\n    function createTemplate(\n        bytes32 providerId,\n        bytes32 endpointId,\n        address fulfillAddress,\n        address errorAddress,\n        bytes4 fulfillFunctionId,\n        bytes4 errorFunctionId,\n        bytes calldata parameters\n        )\n        external\n        returns (bytes32 templateId);\n\n    function getTemplate(bytes32 templateId)\n        external\n        view\n        returns (\n            bytes32 providerId,\n            bytes32 endpointId,\n            address fulfillAddress,\n            address errorAddress,\n            bytes4 fulfillFunctionId,\n            bytes4 errorFunctionId,\n            bytes memory parameters\n        );\n}"
    },
    "contracts/EndpointStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\nimport \"./interfaces/IEndpointStore.sol\";\nimport \"./interfaces/IAuthorizer.sol\";\nimport \"./ProviderStore.sol\";\n\n\n/// @title The contract where the endpoints are stored\n/// @notice This contract is used by the provider to create an ID for their\n/// endpoints so that clients can refer to them while making requests. It also\n/// allows the provider to set an authorization policy for their endpoints,\n/// which both the oracle node and the requester can check to verify\n/// authorization.\ncontract EndpointStore is ProviderStore, IEndpointStore {\n    // apiId is used to tag endpoints to specify that they belong to the same\n    // group (or API). This can be used to enforce API-level authorization\n    // policies. If you are going to treat your endpoints individually, feel\n    // free to leave apiId as 0.\n    struct Endpoint {\n        bytes32 providerId;\n        bytes32 apiId;\n        address[] authorizers;\n        }\n\n    mapping(bytes32 => Endpoint) private endpoints;\n    uint256 private noEndpoints = 0;\n\n\n    /// @notice Creates an endpoint with the given parameters, addressable by\n    /// the ID it returns\n    /// @param providerId Provider ID from ProviderStore\n    /// @param apiId API ID\n    /// @param authorizers Authorizer contract addresses\n    /// @return endpointId Endpoint ID\n    function createEndpoint(\n        bytes32 providerId,\n        bytes32 apiId,\n        address[] calldata authorizers\n        )\n        external\n        override\n        onlyProviderAdmin(providerId)\n        returns(bytes32 endpointId)\n    {\n        endpointId = keccak256(abi.encodePacked(\n            noEndpoints++,\n            this,\n            msg.sender,\n            uint256(0)\n            ));\n        endpoints[endpointId] = Endpoint({\n            providerId: providerId,\n            apiId: apiId,\n            authorizers: authorizers\n        });\n        emit EndpointCreated(\n            endpointId,\n            providerId,\n            apiId,\n            authorizers\n            );\n    }\n\n    /// @notice Updates the endpoint\n    /// @dev Endpoints cannot be transferred to other providers\n    /// @param endpointId Endpoint ID\n    /// @param apiId API ID\n    /// @param authorizers Authorizer contract addresses\n    function updateEndpoint(\n        bytes32 endpointId,\n        bytes32 apiId,\n        address[] calldata authorizers\n        )\n        external\n        override\n        onlyProviderAdmin(endpoints[endpointId].providerId)\n    {\n        endpoints[endpointId].apiId = apiId;\n        endpoints[endpointId].authorizers = authorizers;\n        emit EndpointUpdated(\n            endpointId,\n            apiId,\n            authorizers\n            );\n    }\n\n    /// @notice Retrieves the endpoint parameters addressed by the ID\n    /// @param endpointId Endpoint ID\n    /// @return providerId Provider ID from ProviderStore\n    /// @return apiId API ID\n    /// @return authorizers Authorizer contract addresses\n    function getEndpoint(bytes32 endpointId)\n        external\n        view\n        override\n        returns(\n            bytes32 providerId,\n            bytes32 apiId,\n            address[] memory authorizers\n        )\n    {\n        providerId = endpoints[endpointId].providerId;\n        apiId = endpoints[endpointId].apiId;\n        authorizers = endpoints[endpointId].authorizers;\n    }\n\n    /// @notice Uses authorizer contracts of an endpoint to decide if a client\n    /// contract is authorized to call an endpoint. Once an oracle receives a\n    /// request, it calls this method to determine if it should respond.\n    /// Similarly, third parties can use this method to determine if a client\n    /// contract is authorized to call an endpoint.\n    /// @dev Authorizer contracts are not trusted, so this method should only\n    /// be called off-chain.\n    /// The elements of the authorizer array are either addresses of Authorizer\n    /// contracts with the interface defined in IAuthorizer or 0.\n    /// Say we have authorizer contracts X, Y, Z, T, and our authorizer\n    /// array is [X, Y, 0, Z, T]. This means that the requester should satisfy\n    /// (X AND Y) OR (Z AND T) to be considered authorized. In other words,\n    /// consequent authorizer contracts need to verify authorization\n    /// simultaneously, while 0 represents the start of an independent\n    /// authorization policy. From a logical standpoint, consequent authorizers\n    /// get ANDed while 0 acts as an OR gate, providing great flexibility in\n    /// forming an authorization policy out of simple building blocks. We could\n    /// also define a NOT gate here to achieve a full set of universal logic\n    /// gates, but that does not make much sense in this context because\n    /// authorizers tend to check for positive conditions (have paid, is\n    /// whitelisted, etc.) and we would not need policies that require these to\n    /// be false.\n    /// Note that authorizers should not start or end with 0, and 0s should\n    /// not be used consecutively (e.g., [X, Y, 0, 0, Z, T]).\n    /// [] returns false (deny everyone), [0] returns true (accept everyone).\n    /// @param endpointId Endpoint ID from EndpointStore\n    /// @param clientAddress Address of the client contract\n    /// @return status If the client contract is authorized to call the\n    /// endpoint\n    function checkAuthorizationStatus(\n        bytes32 endpointId,\n        address clientAddress\n        )\n        external\n        view\n        override\n        returns(bool status)\n    {\n        uint256 noAuthorizers = endpoints[endpointId].authorizers.length;\n        // If no authorizers have been set, deny access by default\n        if (noAuthorizers == 0)\n        {\n            return false;\n        }\n        // authorizedByAll will remain true as long as none of the authorizers\n        // in a group reports that the client is unauthorized\n        bool authorizedByAll = true;\n        for (uint256 ind = 0; ind < noAuthorizers; ind++)\n        {\n            address authorizerAddress = endpoints[endpointId].authorizers[ind];\n            if (authorizerAddress == address(0)) {\n                // If we have reached a 0 without getting any unauthorized\n                // reports, we can return true\n                if  (authorizedByAll) {\n                    return true;\n                }\n                // Otherwise, reset authorizedByAll and start checking the next\n                // group\n                authorizedByAll = true;\n            }\n            // We only need to check the next authorizer if we have a good track\n            // record for this group\n            else if (authorizedByAll) {\n                IAuthorizer authorizer = IAuthorizer(authorizerAddress);\n                // Set authorizedByAll to false if we got an unauthorized report.\n                // This means that we will not be able to return a true from\n                // this group of authorizers.\n                if (!authorizer.checkIfAuthorized(endpointId, clientAddress)) {\n                    authorizedByAll = false;\n                }\n            }\n        }\n        // Finally, if we have reached the end of the authorizers (i.e., we\n        // are at the last element of the last group), just return the current\n        // authorizedByAll, which will only be true if all authorizers from the\n        // last group have returned true.\n        return authorizedByAll;\n    }\n}\n"
    },
    "contracts/interfaces/IAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\n\ninterface IAuthorizer {\n    function checkIfAuthorized(\n        bytes32 endpointId,\n        address requester\n        )\n        external\n        view\n        returns (bool status);\n}\n"
    },
    "contracts/ProviderStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\nimport \"./interfaces/IProviderStore.sol\";\nimport \"./RequesterStore.sol\";\n\n\n/// @title The contract where the providers are stored\n/// @notice This contract is mostly for the management of requester-designated\n/// wallets. If a requester wants to receive services from a provider, they\n/// first make a wallet designation request. The provider node fulfills this by\n/// designating a wallet automatically, and the requester can then fund that\n/// wallet. When a client contract endorsed by the requester makes a request to\n/// the provider, this designated wallet is used by the provider to fund the\n/// gas costs of the fulfillment. The requester can also use this contract to\n/// request the withdrawal of all the funds in their designated wallet.\ncontract ProviderStore is RequesterStore, IProviderStore {\n    struct Provider {\n        address admin;\n        string xpub;\n        address walletDesignator;\n        uint256 walletDesignationDeposit;\n        uint256 minBalance;\n        mapping(address => uint256) walletAddressToInd;\n        mapping(uint256 => address) walletIndToAddress;\n        mapping(bytes32 => uint256) requesterIdToWalletInd;\n        uint256 nextWalletInd;\n        }\n\n    struct WalletDesignationRequest {\n        bytes32 providerId;\n        bytes32 requesterId;\n        uint256 walletInd;\n        uint256 depositAmount;\n    }\n\n    struct WithdrawalRequest {\n        bytes32 providerId;\n        bytes32 requesterId;\n        address destination;\n        }\n\n    mapping(bytes32 => Provider) private providers;\n    mapping(bytes32 => WalletDesignationRequest) private walletDesignationRequests;\n    mapping(bytes32 => WithdrawalRequest) private withdrawalRequests;\n    uint256 private noProviders = 0;\n    uint256 private noWalletDesignationRequests = 0;\n    uint256 private noWithdrawalRequests = 0;\n\n\n    /// @notice Creates a provider with the given parameters, addressable by\n    /// the ID it returns\n    /// @dev walletDesignator and xpub are not set here, assuming the\n    /// provider will not have generated them at the time of provider creation\n    /// @param admin Provider admin\n    /// @param walletDesignationDeposit Amount the requesters need to deposit to\n    /// have a wallet designated. It should at least cover the gas cost of\n    /// calling fulfillWalletDesignation().\n    /// @param minBalance The minimum balance the provider expects a requester\n    /// to have in their designated wallet to attempt to fulfill requests from\n    /// their endorsed client contracts. It should cover the gas cost of calling\n    /// fail() from Airnode.sol a few times.\n    /// @return providerId Provider ID\n    function createProvider(\n        address admin,\n        uint256 walletDesignationDeposit,\n        uint256 minBalance\n        )\n        external\n        override\n        returns (bytes32 providerId)\n    {\n        providerId = keccak256(abi.encodePacked(\n            noProviders++,\n            this,\n            msg.sender,\n            uint256(1)\n            ));\n        providers[providerId] = Provider({\n            admin: admin,\n            xpub: \"\",\n            walletDesignator: address(0),\n            walletDesignationDeposit: walletDesignationDeposit,\n            minBalance: minBalance,\n            nextWalletInd: 1\n            });\n        emit ProviderCreated(\n            providerId,\n            admin,\n            walletDesignationDeposit,\n            minBalance\n            );\n    }\n\n    /// @notice Updates the provider\n    /// @param providerId Provider ID\n    /// @param admin Provider admin\n    /// @param walletDesignationDeposit Amount the requesters need to deposit to\n    /// have a wallet designated. It should at least cover the gas cost of\n    /// calling fulfillWalletDesignation().\n    /// @param minBalance The minimum balance the provider expects a requester\n    /// to have in their designated wallet to attempt to fulfill requests from\n    /// their endorsed client contracts. It should cover the gas cost of calling\n    /// fail() from Airnode.sol a few times.\n    function updateProvider(\n        bytes32 providerId,\n        address admin,\n        uint256 walletDesignationDeposit,\n        uint256 minBalance\n        )\n        external\n        override\n        onlyProviderAdmin(providerId)\n    {\n        providers[providerId].admin = admin;\n        providers[providerId].walletDesignationDeposit = walletDesignationDeposit;\n        providers[providerId].minBalance = minBalance;\n        emit ProviderUpdated(\n            providerId,\n            admin,\n            walletDesignationDeposit,\n            minBalance\n            );\n    }\n\n    /// @notice Initializes the master public key of the provider and the\n    /// address it uses to designate wallets\n    /// @dev Keys can only be initialized once. This means that the provider is\n    /// not allowed to update their node key.\n    /// walletDesignator is typically the address of m/0/0/0 derived from xpub,\n    /// yet it may change with the oracle implementation.\n    /// @param providerId Provider ID\n    /// @param xpub Master public key of the provider\n    /// @param walletDesignator Address the provider uses to designate wallets\n    function initializeProviderKeys(\n        bytes32 providerId,\n        string calldata xpub,\n        address walletDesignator\n        )\n        external\n        override\n        onlyProviderAdmin(providerId)\n    {\n        require(\n            (bytes(providers[providerId].xpub).length == 0) &&\n                (providers[providerId].walletDesignator == address(0)),\n            \"Provider keys are already initialized\"\n            );\n        require(\n            (bytes(xpub).length != 0) && (walletDesignator != address(0)),\n            \"Invalid provider keys\"\n            );\n        providers[providerId].xpub = xpub;\n        providers[providerId].walletDesignator = walletDesignator;\n        emit ProviderKeysInitialized(\n            providerId,\n            xpub,\n            walletDesignator\n            );\n    }\n\n    /// @notice Called by the requester to request a wallet to be designated\n    /// by the provider\n    /// @dev The provider expects walletDesignationDeposit to be sent along with\n    /// this call to cover the subsequent cost of fulfilling the wallet\n    /// designation. The provider is expected to return the remaining amount\n    /// to the designated wallet, yet this is not enforced.\n    /// Anyone can request a wallet to be designated for a requester, not only\n    /// its admin.\n    /// The requester should wait for enough confirmations to trust the\n    /// announced walletInd.\n    /// @param providerId Provider ID\n    /// @param requesterId Requester ID from RequesterStore\n    function requestWalletDesignation(\n        bytes32 providerId,\n        bytes32 requesterId\n    )\n        external\n        payable\n        override\n        returns(uint256 walletInd)\n    {\n        require(\n            providers[providerId].requesterIdToWalletInd[requesterId] == 0,\n            \"A wallet designation request has already been made this provider-requester pair\"\n            );\n        require(\n            msg.value >= providers[providerId].walletDesignationDeposit,\n            \"Send at least walletDesignationDeposit along with your call\"\n            );\n        address walletDesignator = providers[providerId].walletDesignator;\n        require(\n            walletDesignator != address(0),\n            \"Provider wallet designator not set yet\"\n            );\n        walletInd = providers[providerId].nextWalletInd;\n        providers[providerId].requesterIdToWalletInd[requesterId] = walletInd;\n        providers[providerId].nextWalletInd++;\n        bytes32 walletDesignationRequestId = keccak256(abi.encodePacked(\n            noWalletDesignationRequests++,\n            this,\n            msg.sender,\n            uint256(2)\n            ));\n        walletDesignationRequests[walletDesignationRequestId] = WalletDesignationRequest({\n            providerId: providerId,\n            requesterId: requesterId,\n            walletInd: walletInd,\n            depositAmount: msg.value\n            });\n        emit WalletDesignationRequested(\n            providerId,\n            requesterId,\n            walletDesignationRequestId,\n            walletInd,\n            msg.value\n            );\n        (bool success, ) = walletDesignator.call{value: msg.value}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    /// @notice Called to rebroadcast a wallet designation request in case the\n    /// provider node has missed it\n    /// @dev The node must ignore duplicate events\n    /// @param walletDesignationRequestId Wallet designation request ID\n    function rebroadcastWalletDesignationRequest(bytes32 walletDesignationRequestId)\n        external\n        override\n    {\n        bytes32 providerId = walletDesignationRequests[walletDesignationRequestId].providerId;\n        require(\n            providerId != 0,\n            \"No active wallet designation request with walletDesignationRequestId\"\n            );\n        emit WalletDesignationRequested(\n            providerId,\n            walletDesignationRequests[walletDesignationRequestId].requesterId,\n            walletDesignationRequestId,\n            walletDesignationRequests[walletDesignationRequestId].walletInd,\n            walletDesignationRequests[walletDesignationRequestId].depositAmount\n            );\n    }\n\n    /// @notice Designates a provider wallet to fulfill requests and sends\n    /// the remains of what has been sent along with requestWalletDesignation()\n    /// @dev Wallet designations cannot be revoked, so the provider should\n    /// only designate wallets derived from its master key.\n    /// The requester should wait for enough confirmations to trust the\n    /// announced walletAddress.\n    /// @param walletDesignationRequestId Wallet designation request ID\n    /// @param walletAddress Wallet address to be designated\n    function fulfillWalletDesignation(\n        bytes32 walletDesignationRequestId,\n        address walletAddress\n        )\n        external\n        payable\n        override\n    {\n        bytes32 providerId = walletDesignationRequests[walletDesignationRequestId].providerId;\n        bytes32 requesterId = walletDesignationRequests[walletDesignationRequestId].requesterId;\n        uint256 walletInd = walletDesignationRequests[walletDesignationRequestId].walletInd;\n        require(\n            msg.sender == providers[providerId].walletDesignator,\n            \"Only the provider walletDesignator can do this\"\n            );\n        require(\n            providers[providerId].walletAddressToInd[walletAddress] == 0,\n            \"Wallet address already designated\"\n            );\n        require(\n            providers[providerId].requesterIdToWalletInd[requesterId] == walletInd,\n            \"No such designation request has been made\"\n            );\n        providers[providerId].walletAddressToInd[walletAddress] = walletInd;\n        providers[providerId].walletIndToAddress[walletInd] = walletAddress;\n        emit WalletDesignationFulfilled(\n            providerId,\n            requesterId,\n            walletDesignationRequestId,\n            walletAddress,\n            walletInd\n            );\n        delete walletDesignationRequests[walletDesignationRequestId];\n        (bool success, ) = walletAddress.call{value: msg.value}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    /// @notice Called by the requester admin to create a request for the\n    /// provider to send the funds kept in their designated wallet to destination\n    /// @param providerId Provider ID\n    /// @param requesterId Requester ID from RequesterStore\n    /// @param destination Withdrawal destination\n    function requestWithdrawal(\n        bytes32 providerId,\n        bytes32 requesterId,\n        address destination\n    )\n        external\n        override\n        onlyRequesterAdmin(requesterId)\n    {\n        uint256 walletInd = providers[providerId].requesterIdToWalletInd[requesterId];\n        require(\n            walletInd != 0,\n            \"Requester has not requested a wallet designation from this provider\"\n            );\n        require(\n            providers[providerId].walletIndToAddress[walletInd] != address(0),\n            \"Requester has not had a wallet designated by this provider\"\n            );\n        bytes32 withdrawalRequestId = keccak256(abi.encodePacked(\n            noWithdrawalRequests++,\n            this,\n            msg.sender,\n            uint256(3)\n            ));\n        withdrawalRequests[withdrawalRequestId] = WithdrawalRequest({\n            providerId: providerId,\n            requesterId: requesterId,\n            destination: destination\n            });\n        emit WithdrawalRequested(\n            providerId,\n            requesterId,\n            withdrawalRequestId,\n            destination\n            );\n    }\n\n    /// @notice Called by the reserved wallet to fulfill the withdrawal request\n    /// made by the requester\n    /// @dev The oracle sends the funds through this method to emit an event\n    /// that indicates that the withdrawal request has been fulfilled\n    /// @param withdrawalRequestId Withdraw request ID\n    function fulfillWithdrawal(bytes32 withdrawalRequestId)\n        external\n        payable\n        override\n    {\n        bytes32 providerId = withdrawalRequests[withdrawalRequestId].providerId;\n        require(\n            providerId != 0,\n            \"No active withdrawal request with withdrawalRequestId\"\n            );\n        bytes32 requesterId = withdrawalRequests[withdrawalRequestId].requesterId;\n        uint256 walletInd = providers[providerId].requesterIdToWalletInd[requesterId];\n        address walletAddress = providers[providerId].walletIndToAddress[walletInd];\n        require(\n            msg.sender == walletAddress,\n            \"Only the wallet to be withdrawn from can call this\"\n            );\n        address destination = withdrawalRequests[withdrawalRequestId].destination;\n        emit WithdrawalFulfilled(\n            providerId,\n            requesterId,\n            withdrawalRequestId,\n            destination,\n            msg.value\n            );\n        delete withdrawalRequests[withdrawalRequestId];\n        (bool success, ) = destination.call{ value: msg.value }(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    /// @notice Retrieves provider parameters addressed by the ID\n    /// @param providerId Provider ID\n    /// @return admin Provider admin\n    /// @return xpub Master public key of the provider node\n    /// @return walletDesignator Address the provider uses to designate wallets\n    /// @return walletDesignationDeposit Amount the requesters need to deposit to\n    /// have a wallet designated. It should at least cover the gas cost of\n    /// calling fulfillWalletDesignation().\n    /// @return minBalance The minimum balance the provider expects a requester\n    /// to have in their designated wallet to attempt to fulfill requests from\n    /// their endorsed client contracts. It should cover the gas cost of calling\n    /// fail() from Airnode.sol a few times.\n    function getProvider(bytes32 providerId)\n        external\n        view\n        override\n        returns (\n            address admin,\n            string memory xpub,\n            address walletDesignator,\n            uint256 walletDesignationDeposit,\n            uint256 minBalance\n        )\n    {\n        admin = providers[providerId].admin;\n        xpub = providers[providerId].xpub;\n        walletDesignator = providers[providerId].walletDesignator;\n        walletDesignationDeposit = providers[providerId].walletDesignationDeposit;\n        minBalance = providers[providerId].minBalance;\n    }\n\n    /// @notice Retrieves the minBalance of the provider\n    /// @param providerId Provider ID\n    /// @return minBalance The minimum balance the provider expects a requester\n    /// to have in their designated wallet to attempt to fulfill requests from\n    /// their endorsed client contracts. It should cover the gas cost of calling\n    /// fail() from Airnode.sol a few times.\n    function getProviderMinBalance(bytes32 providerId)\n        external\n        view\n        override\n        returns (uint256 minBalance)\n    {\n        minBalance = providers[providerId].minBalance;\n    }\n\n    /// @notice Gets the authorization status of a provider wallet\n    /// @dev The provider does not designate wallet index 0 to anyone, which\n    /// means that if a wallet address maps to an index of 0, it is not\n    /// designated to anyone or authorized to fulfill requests.\n    /// @param providerId Provider ID\n    /// @param walletAddress Wallet address\n    /// @return status If the wallet is authorized to fulfill requests made to\n    /// the provider\n    function getProviderWalletStatus(\n        bytes32 providerId,\n        address walletAddress\n        )\n        public\n        view\n        override\n        returns (bool status)\n    {\n        status = providers[providerId].walletAddressToInd[walletAddress] != 0;\n    }\n\n    /// @notice Gets the index of a provider wallet with its address\n    /// @param providerId Provider ID\n    /// @param walletAddress Wallet address\n    /// @return walletInd Index of the wallet with walletAddress address\n    function getProviderWalletIndWithAddress(\n        bytes32 providerId,\n        address walletAddress\n        )\n        external\n        view\n        override\n        returns (uint256 walletInd)\n    {\n        walletInd = providers[providerId].walletAddressToInd[walletAddress];\n    }\n\n    /// @notice Gets the address of a provider wallet with its index\n    /// @param providerId Provider ID\n    /// @param walletInd Wallet index\n    /// @return walletAddress Address of the wallet with walletInd index\n    function getProviderWalletAddressWithInd(\n        bytes32 providerId,\n        uint256 walletInd\n        )\n        external\n        view\n        override\n        returns (address walletAddress)\n    {\n        walletAddress = providers[providerId].walletIndToAddress[walletInd];\n    }\n\n    /// @notice Gets the index of the provider wallet reserved by the requester\n    /// @param providerId Provider ID\n    /// @param requesterId Requester ID from RequestStore\n    /// @return walletInd Wallet index reserved by the requester with requesterId\n    function getProviderWalletIndWithRequesterId(\n        bytes32 providerId,\n        bytes32 requesterId\n        )\n        external\n        view\n        override\n        returns (uint256 walletInd)\n    {\n        walletInd = providers[providerId].requesterIdToWalletInd[requesterId];\n    }\n\n    /// @dev Reverts if the caller is not the provider admin\n    /// @param providerId Provider ID\n    modifier onlyProviderAdmin(bytes32 providerId)\n    {\n        require(\n            msg.sender == providers[providerId].admin,\n            \"Caller is not the provider admin\"\n            );\n        _;\n    }\n}\n"
    },
    "contracts/RequesterStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\nimport \"./interfaces/IRequesterStore.sol\";\n\n\n/// @title The contract where the requesters are stored\n/// @notice This contract is used by requesters to manage their endorsemenets.\n/// The requester first gets a wallet designated from a provider through\n/// ProviderStore. This wallet is used to fulfill requests made by clients\n/// endorsed by the requester. This is the contract where clients allow\n/// requesters to endorse them and requesters endorse or disendorse clients.\ncontract RequesterStore is IRequesterStore {\n    mapping(bytes32 => address) private requesterIdToAdmin;\n    mapping(address => bytes32) private endorsementPermissions;\n    mapping(address => bytes32) private clientAdressToRequesterId;\n    uint256 private noRequesters = 0;\n\n\n    /// @notice Creates a requester with the given parameters, addressable by\n    /// the ID it returns\n    /// @param admin Requester admin\n    /// @return requesterId Requester ID\n    function createRequester(address admin)\n        external\n        override\n        returns (bytes32 requesterId)\n    {\n        requesterId = keccak256(abi.encodePacked(\n            noRequesters++,\n            this,\n            msg.sender,\n            uint256(4)\n            ));\n        requesterIdToAdmin[requesterId] = admin;\n        emit RequesterCreated(\n            requesterId,\n            admin\n            );\n    }\n\n    /// @notice Updates the requester admin\n    /// @param requesterId Requester ID\n    /// @param admin Requester admin\n    function updateRequesterAdmin(\n        bytes32 requesterId,\n        address admin\n        )\n        external\n        override\n        onlyRequesterAdmin(requesterId)\n    {\n        requesterIdToAdmin[requesterId] = admin;\n        emit RequesterUpdated(\n            requesterId,\n            admin\n            );\n    }\n\n    /// @notice Called by the client to permit a requester to endorse it\n    /// @dev Client can be a wallet or a contract.\n    /// @param requesterId Requester ID\n    function updateEndorsementPermission(bytes32 requesterId)\n        external\n        override\n    {\n        endorsementPermissions[msg.sender] = requesterId;\n    }\n\n    /// @notice Called by the requester admin to allow a client to use its\n    /// designated wallets\n    /// @dev This is not provider specific, i.e., the requester allows the\n    /// client's requests to be fulfilled through its designated wallets across\n    /// all providers\n    /// @param requesterId Requester ID\n    /// @param clientAddress Client address\n    function endorseClient(\n        bytes32 requesterId,\n        address clientAddress\n        )\n        external\n        override\n        onlyRequesterAdmin(requesterId)\n    {\n        require(\n            endorsementPermissions[clientAddress] == requesterId,\n            \"Client has not permitted this requester to endorse it\"\n            );\n        clientAdressToRequesterId[clientAddress] = requesterId;\n        emit ClientEndorsed(\n            requesterId,\n            clientAddress\n            );\n    }\n\n    /// @notice Called by the requester admin to disallow a client from using\n    /// its designated wallets\n    /// @dev This is one-sided, meaning that it does not require permission\n    /// from the client. It requires the caller to be the current\n    /// endorser of the client.\n    /// @param requesterId Requester ID\n    /// @param clientAddress Client address\n    function disendorseClient(\n        bytes32 requesterId,\n        address clientAddress\n        )\n        external\n        override\n        onlyRequesterAdmin(requesterId)\n    {\n        require(\n            clientAdressToRequesterId[clientAddress] == requesterId,\n            \"Caller is not the endorser of the client\"\n            );\n        clientAdressToRequesterId[clientAddress] = 0;\n        emit ClientDisendorsed(\n            requesterId,\n            clientAddress\n            );\n    }\n\n    /// @notice Retrieves the requester admin\n    /// @param requesterId Requester ID\n    /// @return admin Requester admin\n    function getRequesterAdmin(bytes32 requesterId)\n        external\n        view\n        override\n        returns (address admin)\n    {\n        admin = requesterIdToAdmin[requesterId];\n    }\n\n    /// @notice Retrieves the ID of the endorser of a client\n    /// @param clientAddress Client address\n    /// @return requesterId Requester ID\n    function getClientRequesterId(address clientAddress)\n        external\n        view\n        override\n        returns (bytes32 requesterId)\n    {\n        requesterId = clientAdressToRequesterId[clientAddress];\n    }\n\n    /// @notice Retrieves the ID of the requester the client has permitted to\n    /// be its endorser\n    /// @param clientAddress Client address\n    /// @return requesterId Requester ID\n    function getClientPermittedEndorser(address clientAddress)\n        external\n        view\n        override\n        returns (bytes32 requesterId)\n    {\n        requesterId = endorsementPermissions[clientAddress];\n    }\n\n    /// @dev Reverts if the caller is not the requester admin\n    /// @param requesterId Requester ID\n    modifier onlyRequesterAdmin(bytes32 requesterId)\n    {\n        require(\n            msg.sender == requesterIdToAdmin[requesterId],\n            \"Caller is not the requester admin\"\n            );\n        _;\n    }\n}\n"
    },
    "contracts/TemplateStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\nimport \"./interfaces/ITemplateStore.sol\";\n\n\n/// @title The contract where request templates are stored\n/// @notice Most requests are repeated many times with the same parameters.\n/// This contract allows the requester to announce their parameters once, then\n/// refer to that announcement when they are making a request, instead of\n/// passing the same parameters repeatedly.\ncontract TemplateStore is ITemplateStore {\n    struct Template {\n        bytes32 providerId;\n        bytes32 endpointId;\n        address fulfillAddress;\n        address errorAddress;\n        bytes4 fulfillFunctionId;\n        bytes4 errorFunctionId;\n        bytes parameters;\n        }\n\n    mapping(bytes32 => Template) internal templates;\n\n\n    /// @notice Creates a template with the given parameters, addressable by\n    /// the ID it returns\n    /// @dev A specific set of request parameters will always have\n    /// the same ID. This means that you can compute the expected ID of a set\n    /// of parameters off-chain. It also means that creating a new template\n    /// with the same parameters will overwrite the old one and return the\n    /// same template ID.\n    /// Note that the requester may choose to use a template, but not its\n    /// fulfill/error destinations. For example, among the methods used to make\n    /// individual requests in Airnode.sol, only makeShortRequest() uses these.\n    /// In addition, the static parameters encoded in the template can be\n    /// overriden by the dynamic parameters provided at runtime.\n    /// @param providerId Provider ID from ProviderStore\n    /// @param endpointId Endpoint ID from EndpointStore\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param errorAddress Address that will be called to error\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param errorFunctionId Signature of the function that will be called\n    /// to error\n    /// @param parameters Static request parameters (i.e., parameters that will\n    /// not change between requests, unlike the dynamic parameters determined\n    /// at runtime)\n    /// @return templateId Request template ID\n    function createTemplate(\n        bytes32 providerId,\n        bytes32 endpointId,\n        address fulfillAddress,\n        address errorAddress,\n        bytes4 fulfillFunctionId,\n        bytes4 errorFunctionId,\n        bytes calldata parameters\n        )\n        external\n        override\n        returns (bytes32 templateId)\n    {\n        templateId = keccak256(abi.encodePacked(\n            providerId,\n            endpointId,\n            fulfillAddress,\n            errorAddress,\n            fulfillFunctionId,\n            errorFunctionId,\n            parameters\n            ));\n        templates[templateId] = Template({\n            providerId: providerId,\n            endpointId: endpointId,\n            fulfillAddress: fulfillAddress,\n            errorAddress: errorAddress,\n            fulfillFunctionId: fulfillFunctionId,\n            errorFunctionId: errorFunctionId,\n            parameters: parameters\n        });\n        emit TemplateCreated(\n          templateId,\n          providerId,\n          endpointId,\n          fulfillAddress,\n          errorAddress,\n          fulfillFunctionId,\n          errorFunctionId,\n          parameters\n          );\n    }\n\n    /// @notice Retrieves request parameters addressed by the ID\n    /// @param templateId Request template ID\n    /// @return providerId Provider ID from ProviderStore\n    /// @return endpointId Endpoint ID from EndpointStore\n    /// @return fulfillAddress Address that will be called to fulfill\n    /// @return errorAddress Address that will be called to error\n    /// @return fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @return errorFunctionId Signature of the function that will be called\n    /// to error\n    /// @return parameters Static request parameters (i.e., parameters that will\n    /// not change between requests, unlike the dynamic parameters determined\n    /// at runtime)\n    function getTemplate(bytes32 templateId)\n        external\n        view\n        override\n        returns (\n            bytes32 providerId,\n            bytes32 endpointId,\n            address fulfillAddress,\n            address errorAddress,\n            bytes4 fulfillFunctionId,\n            bytes4 errorFunctionId,\n            bytes memory parameters\n        )\n    {\n        providerId = templates[templateId].providerId;\n        endpointId = templates[templateId].endpointId;\n        fulfillAddress = templates[templateId].fulfillAddress;\n        errorAddress = templates[templateId].errorAddress;\n        fulfillFunctionId = templates[templateId].fulfillFunctionId;\n        errorFunctionId = templates[templateId].errorFunctionId;\n        parameters = templates[templateId].parameters;\n    }\n}\n"
    },
    "contracts/AirnodeClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\nimport \"./interfaces/IAirnodeClient.sol\";\nimport \"./interfaces/IAirnode.sol\";\n\n\n/// @title The contract to be inherited from to use Airnode to make requests\n/// @notice In addition to referencing the Airnode contract instance it uses,\n/// the contract authorizes a requester to endorse it by announcing its\n/// ID at requesterId.\ncontract AirnodeClient is IAirnodeClient {\n    IAirnode public airnode;\n\n    /// @dev Airnode address and the endorser ID are set at deployment. If you\n    /// need to be able to update them, you will have to implement that\n    /// functionality (and probably put it behind onlyOwner).\n    /// @param _airnode Airnode contract address\n    /// @param _requesterId Requester ID from RequestStore\n    constructor (\n        address _airnode,\n        bytes32 _requesterId\n        )\n        public\n    {\n        airnode = IAirnode(_airnode);\n        airnode.updateEndorsementPermission(_requesterId);\n    }\n\n    /// @notice Returns the Airnode contract address used by this client\n    /// @return _airnodeAddress Airnode contract address\n    function airnodeAddress()\n        external\n        view\n        override\n        returns(address _airnodeAddress)\n    {\n        _airnodeAddress = address(airnode);\n    }\n\n    /// @dev Reverts if the caller is not the Airnode contract\n    /// Use it as a modifier for fulfill and error callback methods\n    modifier onlyAirnode()\n    {\n        require(\n            msg.sender == address(airnode),\n            \"Can only be called by the designated Airnode contract\"\n            );\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IAirnodeClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\n\ninterface IAirnodeClient {\n  function airnodeAddress()\n      external\n      view\n      returns(address);\n}\n"
    },
    "contracts/Authorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\n\n/// @title An abstract contract that describes the general interface of an\n/// authorizer contract\n/// @notice This contract tells if a requester is authorized to call an\n/// endpoint. The requester may need to prepay to subscribe to the endpoint\n/// or go through KYC to get whitelisted. Each rule can be implemented as a\n/// separate authorizer contract.\nabstract contract Authorizer {\n    /// Authorizer types can be identified by their authorizerType, yet all\n    /// types have the same verifyAuthorization() interface.\n    uint public authorizerType;\n\n    /// @notice Verifies the authorization status of the requester for calling\n    /// the endpoint according to this authorizer contract\n    /// @param requester Requester contract address\n    /// @param endpointId Endpoint ID from EndpointStore\n    /// @return status Authorization status of the requester for calling the\n    /// endpoint according to this authorizer contract\n    function checkIfAuthorized(\n        bytes32 endpointId,\n        address requester\n        )\n        virtual\n        external\n        view\n        returns (bool status);\n}\n"
    },
    "contracts/Convenience.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IConvenience.sol\";\nimport \"./interfaces/IAirnode.sol\";\n\n\ncontract Convenience is IConvenience {\n    IAirnode public airnode;\n\n\n    constructor (address _airnode)\n        public\n    {\n        airnode = IAirnode(_airnode);\n    }\n\n    function getTemplates(bytes32[] calldata templateIds)\n        external\n        view\n        override\n        returns (\n            bytes32[] memory providerIds,\n            bytes32[] memory endpointIds,\n            address[] memory fulfillAddresses,\n            address[] memory errorAddresses,\n            bytes4[] memory fulfillFunctionIds,\n            bytes4[] memory errorFunctionIds,\n            bytes[] memory parameters\n        )\n    {\n        providerIds = new bytes32[](templateIds.length);\n        endpointIds = new bytes32[](templateIds.length);\n        fulfillAddresses = new address[](templateIds.length);\n        errorAddresses = new address[](templateIds.length);\n        fulfillFunctionIds = new bytes4[](templateIds.length);\n        errorFunctionIds = new bytes4[](templateIds.length);\n        parameters = new bytes[](templateIds.length);\n        for (uint256 ind = 0; ind < templateIds.length; ind++)\n        {\n            (\n                providerIds[ind],\n                endpointIds[ind],\n                fulfillAddresses[ind],\n                errorAddresses[ind],\n                fulfillFunctionIds[ind],\n                errorFunctionIds[ind],\n                parameters[ind]\n            ) = airnode.getTemplate(templateIds[ind]);\n        }\n    }\n\n    /// @notice Gets a wide array of data using the client address\n    /// @param providerId Provider ID from ProviderStore\n    /// @param clientAddress Client address\n    /// @return requesterId The endorser of the client\n    /// @return walletInd The index of the wallet to be used to fulfill the\n    /// client's requests\n    /// @return walletAddress The address of the wallet to be used to fulfill\n    /// the client's requests\n    /// @return walletBalance The balance of the wallet to be used to fulfill\n    /// the client's requests\n    /// @return minBalance The minimum balance the provider expects walletBalance\n    /// to be to fulfill requests from the client\n    function getDataWithClientAddress(\n        bytes32 providerId,\n        address clientAddress\n        )\n        external\n        view\n        override\n        returns (\n            bytes32 requesterId,\n            uint256 walletInd,\n            address walletAddress,\n            uint256 walletBalance,\n            uint256 minBalance\n            )\n    {\n        requesterId = airnode.getClientRequesterId(clientAddress);\n        walletInd = airnode.getProviderWalletIndWithRequesterId(\n            providerId,\n            requesterId\n            );\n        walletAddress = airnode.getProviderWalletAddressWithInd(\n            providerId,\n            walletInd\n            );\n        walletBalance = walletAddress.balance;\n        minBalance = airnode.getProviderMinBalance(providerId);\n    }\n\n    function getDataWithClientAddresses(\n        bytes32 providerId,\n        address[] calldata clientAddresses\n        )\n        external\n        view\n        override\n        returns (\n            bytes32[] memory requesterIds,\n            uint256[] memory walletInds,\n            address[] memory walletAddresses,\n            uint256[] memory walletBalances,\n            uint256[] memory minBalances\n            )\n    {\n        requesterIds = new bytes32[](clientAddresses.length);\n        walletInds = new uint256[](clientAddresses.length);\n        walletAddresses = new address[](clientAddresses.length);\n        walletBalances = new uint256[](clientAddresses.length);\n        minBalances = new uint256[](clientAddresses.length);\n\n        for (uint256 ind = 0; ind < clientAddresses.length; ind++)\n        {\n            bytes32 requesterId = airnode.getClientRequesterId(clientAddresses[ind]);\n            uint256 walletInd = airnode.getProviderWalletIndWithRequesterId(\n                providerId,\n                requesterId\n                );\n            address walletAddress = airnode.getProviderWalletAddressWithInd(\n                providerId,\n                walletInd\n                );\n            requesterIds[ind] = requesterId;\n            walletInds[ind] = walletInd;\n            walletAddresses[ind] = walletAddress;\n            walletBalances[ind] = walletAddress.balance;\n            minBalances[ind] = airnode.getProviderMinBalance(providerId);\n        }\n    }\n\n    function checkAuthorizationStatuses(\n        bytes32[] calldata endpointIds,\n        address[] calldata clientAddresses\n        )\n        external\n        view\n        override\n        returns (bool[] memory statuses)\n    {\n        require(\n            endpointIds.length == clientAddresses.length,\n            \"The number of endpoints should be equal to the number of clients\"\n        );\n        statuses = new bool[](endpointIds.length);\n        for (uint256 ind = 0; ind < endpointIds.length; ind++)\n        {\n            statuses[ind] = airnode.checkAuthorizationStatus(endpointIds[ind], clientAddresses[ind]);\n        }\n    }\n}"
    },
    "contracts/interfaces/IConvenience.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\n\ninterface IConvenience {\n    function getTemplates(bytes32[] calldata templateIds)\n        external\n        view\n        returns (\n            bytes32[] memory providerIds,\n            bytes32[] memory endpointIds,\n            address[] memory fulfillAddresses,\n            address[] memory errorAddresses,\n            bytes4[] memory fulfillFunctionIds,\n            bytes4[] memory errorFunctionIds,\n            bytes[] memory parameters\n        );\n\n    function getDataWithClientAddress(\n        bytes32 providerId,\n        address clientAddress\n        )\n        external\n        view\n        returns (\n            bytes32 requesterId,\n            uint256 walletInd,\n            address walletAddress,\n            uint256 walletBalance,\n            uint256 minBalance\n            );\n\n    function getDataWithClientAddresses(\n        bytes32 providerId,\n        address[] calldata clientAddresses\n        )\n        external\n        view\n        returns (\n            bytes32[] memory requesterIds,\n            uint256[] memory walletInds,\n            address[] memory walletAddresses,\n            uint256[] memory walletBalances,\n            uint256[] memory minBalances\n            );\n\n    function checkAuthorizationStatuses(\n        bytes32[] calldata endpointIds,\n        address[] calldata clientAddresses\n        )\n        external\n        view\n        returns (bool[] memory statuses);\n}\n"
    },
    "contracts/ExampleAirnodeClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\nimport \"./AirnodeClient.sol\";\n\n\n/// @title An example Airnode client contract\ncontract ExampleAirnodeClient is AirnodeClient {\n    bytes32 public data;\n    bytes32 public requestId;\n    uint256 public errorCode;\n\n\n    /// @dev Airnode address and endorser IDs are set at deployment\n    /// @param _airnode Airnode contract address\n    /// @param _requesterId Endorser ID from RequestStore\n    constructor (\n        address _airnode,\n        bytes32 _requesterId\n        )\n        public\n        AirnodeClient(_airnode, _requesterId)\n    {}\n\n    /// @notice Called to make a regular request to the Airnode contract\n    /// @param templateId Template ID from TemplateStore\n    /// @param parameters Dynamic request parameters (i.e., parameters that are\n    /// determined at runtime, unlike the static parameters stored in the\n    /// template)\n    function request(\n        bytes32 templateId,\n        bytes calldata parameters\n        )\n        external\n    {\n        requestId = airnode.makeRequest(\n            templateId,\n            address(this),\n            address(this),\n            this.fulfill.selector,\n            this.error.selector,\n            parameters\n            );\n    }\n\n    /// @notice Called by the provider wallet through the Airnode contract to\n    /// deliver the response\n    /// @param _requestId Request ID\n    /// @param _data Data returned by the provider\n    function fulfill(\n        bytes32 _requestId,\n        bytes32 _data\n        )\n        external\n        onlyAirnode()\n    {\n        require(\n            _requestId == requestId,\n            \"Example request ID check\"\n            );\n        data = _data;\n    }\n\n    /// @notice Called by the provider wallet through the Airnode contract if\n    /// the fulfillment has failed\n    /// @param _requestId Request ID\n    /// @param _errorCode Error code\n    function error(\n        bytes32 _requestId,\n        uint256 _errorCode\n        )\n        external\n        onlyAirnode()\n    {\n        require(\n            _requestId == requestId,\n            \"Example request ID check\"\n            );\n        errorCode = _errorCode;\n    }\n}\n"
    },
    "contracts/Migrations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\n\ncontract Migrations {\n    address public owner;\n    uint256 public last_completed_migration;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    function setCompleted(uint256 completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}